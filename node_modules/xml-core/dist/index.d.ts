/**
 * Base interface for collections
 *
 * @interface ICollection
 * @template I
 */
interface ICollection<I> {
    readonly Count: number;
    Item(index: number): I | null;
    Add(item: I): void;
    Pop(): I | undefined;
    RemoveAt(index: number): void;
    Clear(): void;
    GetIterator(): I[];
    ForEach(cb: (item: I, index: number, array: I[]) => void): void;
    Map<U>(cb: (item: I, index: number, array: I[]) => U): ICollection<U>;
    Filter(cb: (item: I, index: number, array: I[]) => boolean): ICollection<I>;
    Sort(cb: (a: I, b: I) => number): ICollection<I>;
    Every(cb: (value: I, index: number, array: I[]) => boolean): boolean;
    Some(cb: (value: I, index: number, array: I[]) => boolean): boolean;
    IsEmpty(): boolean;
}
interface IXmlSerializable {
    /**
     * Writes object to XML node
     * - if class was initialized and it has no one change, GetXml returns null
     * @returns Node
     */
    GetXml(): Node | null;
    /**
     * Reads XML from string
     * @param  {Node} node
     * @returns void
     */
    LoadXml(node: Node | string): void;
}
declare type IXmlSerializableConstructor = new () => IXmlSerializable;
/**
 * Base type for associated arrays
 *
 * @interface AssocArray
 * @template T
 */
interface AssocArray<T> {
    [index: string]: T;
}
declare type XmlBufferEncoding = string | "utf8" | "binary" | "hex" | "base64" | "base64url";
declare type ISelectResult = Node[] | Node | boolean | number | string;
interface XmlNamespace {
    /**
     * Prefix
     *
     * @type {(string |)}
     * @memberOf XmlNamespace
     */
    prefix: string | null;
    /**
     * Namespace URI
     *
     * @type {(string |)}
     * @memberOf XmlNamespace
     */
    namespace: string | null;
}
interface XmlSchemaItemBase {
    /**
     * Local name of item
     *
     * @type {string}
     * @memberOf XmlSchemaItemBase
     */
    localName?: string;
    /**
     * Namespace URI of attribute
     *
     * @type {(string |)}
     * @memberOf XmlSchemaItemBase
     */
    namespaceURI?: string | null;
    /**
     * Default prefix for Xml element
     *
     * @type {(string |)}
     * @memberOf XmlSchemaItemBase
     */
    prefix?: string | null;
}
interface XmlSchemaItem<T> extends XmlSchemaItemBase {
    /**
     * Default value for item
     *
     * @type {(T |)}
     * @memberOf XmlSchemaItem
     */
    defaultValue?: T | null;
    /**
     * Determine where item is required
     *
     * @type {boolean}
     * @memberOf XmlSchemaItem
     */
    required?: boolean;
    /**
     * Custom converter for item value
     *
     * @type {IConverter<T>}
     * @memberOf XmlAttributeType
     */
    converter?: IConverter<T>;
}
interface XmlSchemaItemParser {
    /**
     * Xml parser for item
     *
     * @type {*}
     * @memberOf XmlSchemaItemParser
     */
    parser?: IXmlSerializableConstructor;
}
interface XmlAttributeType<T> extends XmlSchemaItem<T> {
}
interface XmlContentType<T> {
    /**
     * Default value for item
     *
     * @type {(T |)}
     * @memberOf XmlContentType
     */
    defaultValue?: T | null;
    /**
     * Determine where item is required
     *
     * @type {boolean}
     * @memberOf XmlContentType
     */
    required?: boolean;
    /**
     * Custom converter for item value
     *
     * @type {IConverter<T>}
     * @memberOf XmlContentType
     */
    converter?: IConverter<T>;
}
interface XmlElementType extends XmlSchemaItemBase, XmlSchemaItemParser {
    /**
     * Local name for Xml element
     *
     * @type {string}
     * @memberOf XmlElementType
     */
    localName: string;
    /**
     * Namespace URI fro Xml element
     *
     * @type {(string |)}
     * @memberOf XmlElementType
     */
    namespaceURI?: string | null;
}
interface XmlChildElementType<T> extends XmlSchemaItem<T>, XmlSchemaItemParser {
    /**
     * max occurs of items in collection
     *
     * @type {number}
     * @memberOf XmlChildElementType
     */
    maxOccurs?: number;
    /**
     * min occurs of items in collection
     *
     * @type {number}
     * @memberOf XmlChildElementType
     */
    minOccurs?: number;
    /**
     * Don't add root element of XmlCollection to compiled element
     *
     * @type {boolean}
     * @memberOf XmlChildElementType
     */
    noRoot?: boolean;
}
interface XmlSchema {
    localName?: string;
    namespaceURI?: string | null;
    prefix?: string | null;
    parser?: IXmlSerializableConstructor;
    items?: {
        [key: string]: (XmlChildElementType<any> | XmlAttributeType<any>) & {
            type?: string;
        };
    };
    target?: any;
}
interface IConverter<T> {
    /**
     * Converts value from Xml element to Object
     *
     * @memberOf IConverter
     */
    set: (value: string) => T;
    /**
     * Converts value from Object to Xml element
     *
     * @memberOf IConverter
     */
    get: (value: T) => string | undefined;
}
declare function XmlElement(params: XmlElementType): <TFunction extends Function>(target: TFunction) => void;
declare function XmlChildElement<T>(params?: XmlChildElementType<T>): (target: Object, propertyKey: string | symbol) => void;
declare function XmlAttribute<T>(params?: XmlAttributeType<T>): (target: Object, propertyKey: string) => void;
declare function XmlContent<T>(params?: XmlContentType<T>): (target: Object, propertyKey: string) => void;
declare class Collection<I> implements ICollection<I> {
    protected items: I[];
    constructor(items?: I[]);
    get Count(): number;
    Item(index: number): I | null;
    Add(item: I): void;
    Pop(): I | undefined;
    RemoveAt(index: number): void;
    Clear(): void;
    GetIterator(): I[];
    ForEach(cb: (item: I, index: number, array: I[]) => void): void;
    Map<U>(cb: (item: I, index: number, array: I[]) => U): Collection<U>;
    Filter(cb: (item: I, index: number, array: I[]) => boolean): Collection<I>;
    Sort(cb: (a: I, b: I) => number): Collection<I>;
    Every(cb: (value: I, index: number, array: I[]) => boolean): boolean;
    Some(cb: (value: I, index: number, array: I[]) => boolean): boolean;
    IsEmpty(): boolean;
}
declare class XmlError implements Error {
    stack: any;
    code: number;
    name: string;
    message: string;
    protected readonly prefix = "XMLJS";
    constructor(code: XE, ...args: any[]);
}
declare enum XE {
    NONE = 0,
    NULL_REFERENCE = 1,
    NULL_PARAM = 2,
    DECORATOR_NULL_PARAM = 3,
    COLLECTION_LIMIT = 4,
    METHOD_NOT_IMPLEMENTED = 5,
    METHOD_NOT_SUPPORTED = 6,
    PARAM_REQUIRED = 7,
    CONVERTER_UNSUPPORTED = 8,
    ELEMENT_MALFORMED = 9,
    ELEMENT_MISSING = 10,
    ATTRIBUTE_MISSING = 11,
    CONTENT_MISSING = 12,
    CRYPTOGRAPHIC = 13,
    CRYPTOGRAPHIC_NO_MODULE = 14,
    CRYPTOGRAPHIC_UNKNOWN_TRANSFORM = 15,
    ALGORITHM_NOT_SUPPORTED = 16,
    ALGORITHM_WRONG_NAME = 17,
    XML_EXCEPTION = 18
}
declare class Convert {
    static ToString(buffer: BufferSource, enc?: XmlBufferEncoding): string;
    static FromString(str: string, enc?: XmlBufferEncoding): Uint8Array;
    static ToBase64(buf: Uint8Array): string;
    static FromBase64(base64Text: string): Uint8Array;
    static FromBase64Url(base64url: string): Uint8Array;
    static ToBase64Url(data: Uint8Array): string;
    static FromUtf8String(text: string): Uint8Array;
    static ToUtf8String(buffer: Uint8Array): string;
    static FromBinary(text: string): Uint8Array;
    static ToBinary(buffer: Uint8Array): string;
    /**
     * Converts buffer to HEX string
     * @param  {BufferSource} buffer Incoming buffer
     * @returns string
     */
    static ToHex(buffer: Uint8Array): string;
    /**
     * Converts HEX string to buffer
     *
     * @static
     * @param {string} hexString
     * @returns {Uint8Array}
     *
     * @memberOf Convert
     */
    static FromHex(hexString: string): Uint8Array;
    /**
     * Converts string to Date
     *
     * @static
     * @param {string} dateTime
     * @returns {Date}
     *
     * @memberOf Convert
     */
    static ToDateTime(dateTime: string): Date;
    /**
     * Converts Date to string
     *
     * @static
     * @param {Date} dateTime
     * @returns {string}
     *
     * @memberOf Convert
     */
    static FromDateTime(dateTime: Date): string;
    protected static Base64Padding(base64: string): string;
}
declare const APPLICATION_XML = "application/xml";
declare const DEFAULT_PREFIX = "";
declare const DEFAULT_NAMESPACE_URI = "";
declare enum XmlNodeType {
    None = 0,
    Element = 1,
    Attribute = 2,
    Text = 3,
    CDATA = 4,
    EntityReference = 5,
    Entity = 6,
    ProcessingInstruction = 7,
    Comment = 8,
    Document = 9,
    DocumentType = 10,
    DocumentFragment = 11,
    Notation = 12,
    Whitespace = 13,
    SignificantWhitespace = 14,
    EndElement = 15,
    EndEntity = 16,
    XmlDeclaration = 17
}
declare type SelectNodes = (node: Node, xPath: string) => Node[];
declare const Select: SelectNodes;
declare function Parse(xmlString: string): Document;
declare function Stringify(target: Node): string;
/**
 * Returns single Node from given Node
 *
 * @export
 * @param {Node} node
 * @param {string} path
 * @returns
 */
declare function SelectSingleNode(node: Node, path: string): Node | null;
declare function SelectNamespaces(node: Element): AssocArray<string>;
declare function assign(target: any, ...sources: any[]): any;
/**
 * Returns true if object is a XML Element
 * @param obj Object to test
 */
declare function isElement(obj: any): obj is Element;
/**
 * Returns true if object is a XML Document
 * @param obj Object to test
 */
declare function isDocument(obj: any): obj is Document;
declare const XmlBase64Converter: IConverter<Uint8Array>;
declare const XmlNumberConverter: IConverter<number>;
declare const XmlBooleanConverter: IConverter<boolean>;
declare class XmlCollection<I extends XmlObject> extends XmlObject implements ICollection<I> {
    static parser: any;
    /**
     * The maximum number of elements
     */
    MaxOccurs: number;
    /**
     * The minimum number of elements
     */
    MinOccurs: number;
    protected items: I[];
    HasChanged(): boolean;
    get Count(): number;
    Item(index: number): I | null;
    Add(item: I): void;
    Pop(): I | undefined;
    RemoveAt(index: number): void;
    Clear(): void;
    GetIterator(): I[];
    ForEach(cb: (item: I, index: number, array: I[]) => void): void;
    Map<U>(cb: (item: I, index: number, array: I[]) => U): Collection<U>;
    Filter(cb: (item: I, index: number, array: I[]) => boolean): Collection<I>;
    Sort(cb: (a: I, b: I) => number): Collection<I>;
    Every(cb: (value: I, index: number, array: I[]) => boolean): boolean;
    Some(cb: (value: I, index: number, array: I[]) => boolean): boolean;
    IsEmpty(): boolean;
    protected OnGetXml(element: Element): void;
    protected OnLoadXml(element: Element): void;
}
declare class XmlObject implements IXmlSerializable {
    static LoadXml<T extends XmlObject>(this: new () => T, param: string | Element): T;
    static GetElement(element: Element, name: string, required?: boolean): Element;
    static GetAttribute(element: Element, attrName: string, defaultValue: string | null, required?: boolean): string | null;
    static GetElementById(element: Document | Element, idValue: string): Element | null;
    /**
     * Creates new instance of XmlDocument with given name of root element
     * @param  {string} root Name of root element
     * @param  {string} namespaceUri
     * @param  {string} prefix
     * @returns Document
     */
    static CreateDocument(root?: string, namespaceUri?: string | null, prefix?: string | null): Document;
    static GetChildren(node: Node, localName: string, nameSpace?: string): Element[];
    static GetFirstChild(node: Node, localName: string, nameSpace?: string): Element | null;
    static GetChild(node: Element, localName: string, nameSpace?: string, required?: boolean): Element | null;
    protected static attributes: AssocArray<XmlAttributeType<any>>;
    protected static elements: AssocArray<XmlChildElementType<any>>;
    protected static prefix: string | null;
    protected static namespaceURI: string | null;
    protected static localName: string;
    /**
     * XmlElement
     * undefined - class initialized
     * null - has some changes
     * element - has cached element
     *
     * @protected
     * @type {(Element | null | undefined)}
     * @memberOf XmlObject
     */
    protected element?: Element | null;
    protected prefix: string | null;
    protected localName: string | undefined;
    protected namespaceURI: string | null | undefined;
    get Element(): Element | null | undefined;
    get Prefix(): string | null;
    set Prefix(value: string | null);
    get LocalName(): string;
    get NamespaceURI(): string | null;
    HasChanged(): boolean;
    GetXml(hard?: boolean): Element | null;
    LoadXml(param: string | Element): void;
    /**
     * Returns current Xml as string
     * - if element was initialized without changes, returns empty string
     */
    toString(): string;
    GetElement(name: string, required?: boolean): Element;
    GetChildren(localName: string, nameSpace?: string): Element[];
    GetChild(localName: string, required?: boolean): Element | null;
    GetFirstChild(localName: string, namespace?: string): Element | null;
    GetAttribute(name: string, defaultValue: string | null, required?: boolean): string | null;
    IsEmpty(): boolean;
    protected OnLoadXml(element: Element): void;
    protected GetStatic(): XmlSchema;
    protected GetPrefix(): string;
    protected OnGetXml(element: Element): void;
    protected CreateElement(document?: Document, localName?: string, namespaceUri?: string | null, prefix?: string | null): Element;
    protected CreateDocument(): Document;
}
declare class NamespaceManager extends Collection<XmlNamespace> {
    Add(item: XmlNamespace): void;
    GetPrefix(prefix: string, start?: number): XmlNamespace | null;
    GetNamespace(namespaceUrl: string, start?: number): XmlNamespace | null;
}
export { ICollection, IXmlSerializable, IXmlSerializableConstructor, AssocArray, XmlBufferEncoding, ISelectResult, XmlNamespace, XmlSchemaItemBase, XmlSchemaItem, XmlSchemaItemParser, XmlAttributeType, XmlContentType, XmlElementType, XmlChildElementType, XmlSchema, IConverter, XmlElement, XmlChildElement, XmlAttribute, XmlContent, Collection, Convert, SelectNodes, Select, Parse, Stringify, SelectSingleNode, SelectNamespaces, assign, isElement, isDocument, XmlBase64Converter, XmlNumberConverter, XmlBooleanConverter, XmlError, XE, APPLICATION_XML, DEFAULT_PREFIX, DEFAULT_NAMESPACE_URI, XmlNodeType, XmlCollection, XmlObject, NamespaceManager };
